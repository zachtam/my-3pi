 target C {
  platform: "RP2040",
  threading: false,
  keepalive: true
}

import Display from "lib/Display.lf"

preamble {=
  #include <hardware/gpio.h>
  #include <pico/stdlib.h>
  #define ALARM_NUM 0
  #define ALARM_IRQ TIMER_IRQ_0
=}


main reactor {
  preamble {=
    typedef void (*virtual_timer_callback_t)(void);
 
    // Definition of linked list node 
    typedef struct node_t {
      /* Put the variables needed for linked list node here */
      // value for the timer
      uint32_t timer_value;
      virtual_timer_callback_t cb;
      uint32_t repeat_timer;
      uint32_t node_id;

      /*********************************************
          DO NOT CHANGE THE CODE BELOW
      *********************************************/
      // next node pointer
      struct node_t * next ;
      } node_t ;

    //The linked list for timer
    static node_t* linked_list = NULL;

    // linked list operation functions
    // insert the node in the sorted linked list (linked_list) and return the sorted linked list after the insertion
    void list_insert_sorted(node_t* node){
       if(linked_list == NULL){
          node -> next = NULL;
          linked_list = node;
       }
       else{
          if(linked_list -> timer_value > node -> timer_value){
              node -> next = linked_list;
              linked_list = node;
            }     
          else{
              // node is somewhere after the head
              node_t* prev_node = linked_list;
              node_t* curr_node = linked_list->next;
              while(curr_node != NULL && curr_node -> timer_value < node -> timer_value){
                  // iterate until end of list or the current node has a greater value
                  prev_node = curr_node;
                  curr_node = curr_node -> next;
              }
              // insert node
              prev_node -> next = node;
              node -> next = curr_node;
          } 
       }
    }

    // remove the node from linked list
    void list_remove(node_t* node){
        if(linked_list != NULL){
            if(linked_list == node){
                linked_list = linked_list -> next;
            }
            else{
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list -> next;
                while(curr_node != NULL && curr_node != node){
                    prev_node = curr_node;
                    curr_node = curr_node -> next;
                }
                if(curr_node != NULL){
                    prev_node -> next = curr_node -> next; 
                }
            }
        }
    }
    // return and remove the first node in the linked list
    node_t* list_remove_first(){
      node_t* head = linked_list;
      if (head != NULL) {
          linked_list = head->next;
      }
      return head;
    }
    /*********************************************
        DO NOT CHANGE THE CODE ABOVE
    *********************************************/

    /* You can also create your own linked list functions here. */


    void lab5_timer_irq_handler(void){
        /* TODO */
        irq_set_enabled(ALARM_IRQ, false);
        node_t* timer_node = list_remove_first();
        irq_set_enabled(ALARM_IRQ, true);

        if (timer_node == NULL) {
            hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);
            return;
        }
        timer_node->cb();
        if (timer_node->repeat_timer) {
            timer_node->timer_value += timer_node->repeat_timer;
            irq_set_enabled(ALARM_IRQ, false);
            list_insert_sorted(timer_node);
            irq_set_enabled(ALARM_IRQ, true);
        }
        else {
            free(timer_node);
        }
        uint32_t first_timer_value = linked_list->timer_value;
        timer_hw->alarm[ALARM_NUM] = first_timer_value;
        if (first_timer_value <= timer_hw->timerawl) {
            lab5_timer_irq_handler();
        }

        hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);
        printf("Timer Fired!");
    }
    void virtual_timer_init(void){
        /* TODO */
        hw_set_bits(&timer_hw->inte, 1u << ALARM_NUM);
        irq_set_exclusive_handler(ALARM_IRQ, lab5_timer_irq_handler);
        irq_set_enabled(ALARM_IRQ, true);
    }
    uint32_t virtual_timer_start(uint32_t microseconds, virtual_timer_callback_t cb){
        /* TODO */
        uint32_t cur_time = timer_hw->timerawl;
        uint32_t target = cur_time + microseconds;
        node_t* timer_node = malloc(sizeof(node_t));
        timer_node->timer_value = target;
        timer_node->cb = cb;
        timer_node->repeat_timer = 0;
        timer_node->node_id = cur_time;
        irq_set_enabled(ALARM_IRQ, false);
        list_insert_sorted(timer_node);
        irq_set_enabled(ALARM_IRQ, true);
        uint32_t first_timer_value = linked_list->timer_value;
        timer_hw->alarm[ALARM_NUM] = first_timer_value;
        if (first_timer_value <= timer_hw->timerawl) {
            lab5_timer_irq_handler();
        }
        return cur_time;
    }
    uint32_t virtual_timer_start_repeated(uint32_t microseconds, virtual_timer_callback_t cb){
        /* TODO */
        uint32_t cur_time = timer_hw->timerawl;
        uint32_t target = cur_time + microseconds;
        node_t* timer_node = malloc(sizeof(node_t));
        timer_node->timer_value = target;
        timer_node->cb = cb;
        timer_node->repeat_timer = microseconds;
        timer_node->node_id = cur_time;
        irq_set_enabled(ALARM_IRQ, false);
        list_insert_sorted(timer_node);
        irq_set_enabled(ALARM_IRQ, true);
        uint32_t first_timer_value = linked_list->timer_value;
        timer_hw->alarm[ALARM_NUM] = first_timer_value;
        if (first_timer_value <= timer_hw->timerawl) {
            lab5_timer_irq_handler();
        }
        return cur_time;
    }
    void virtual_timer_cancel(uint32_t time_id ){
        /* TODO */
        irq_set_enabled(ALARM_IRQ, false);
        if(linked_list != NULL){
            if(linked_list->node_id == time_id){
                node_t* curr_node = linked_list;
                linked_list = curr_node -> next;
                free(curr_node);
                if (linked_list != NULL) {
                    timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
                    uint32_t first_timer_value = linked_list->timer_value;
                    if (first_timer_value <= timer_hw->timerawl) {
                        lab5_timer_irq_handler();
                    }
                }
            }
            else{
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list -> next;
                while(curr_node != NULL && curr_node->node_id != time_id){
                    prev_node = curr_node;
                    curr_node = curr_node -> next;
                }
                if(curr_node != NULL){
                    prev_node -> next = curr_node -> next; 
                    free(curr_node);
                    if (linked_list != NULL) {
                        timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
                        uint32_t first_timer_value = linked_list->timer_value;
                        if (first_timer_value <= timer_hw->timerawl) {
                            lab5_timer_irq_handler();
                        }
                    }
                }
            }
        }
        irq_set_enabled(ALARM_IRQ, true);
    }

    void toggleLED() {
        bool led_state = gpio_get(PICO_DEFAULT_LED_PIN);
        gpio_put(PICO_DEFAULT_LED_PIN, !led_state);
    }

    void doNothing() {
        return;
    }

    void onLED() {
        gpio_put(PICO_DEFAULT_LED_PIN, false);
    }

    void offLED() {
        gpio_put(PICO_DEFAULT_LED_PIN, true);
    }

  =}


  timer print_hw_timer(0, 1000ms)
  display = new Display()
  logical action cancelLED
  state led_on:bool = false;
  state cancel_id:uint32_t;

  reaction(startup) -> cancelLED {=
      // initialize the LED and the virtual timer    
      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
      gpio_put(25, true);
      virtual_timer_init();
    //   virtual_timer_start(1000000, onLED);
    //   virtual_timer_start(2000000, offLED);
    //   virtual_timer_start(3000000, onLED);
    //   virtual_timer_start(4000000, offLED);
    //   virtual_timer_start(5000000, onLED);
    //   virtual_timer_start(6000000, offLED);
    //   self->cancel_id = virtual_timer_start_repeated(1000000, toggleLED);
    //   lf_schedule(cancelLED, SEC(5));
    virtual_timer_start_repeated(1000000, toggleLED);
    virtual_timer_start_repeated(2000000, doNothing);
  =}
  

  reaction(print_hw_timer)-> display.line0{=
      /* TODO for 9.2.2 */
      uint32_t cur_time = timer_hw->timelr;
      static char buf[17];
      snprintf(buf, 17, "t:%dus", cur_time);
      lf_set(display.line0, buf);  
  =}

  /* TODO: add reaction and timer to create the environment to test */
  reaction(cancelLED) {=
      virtual_timer_cancel(self->cancel_id);
  =}
}
