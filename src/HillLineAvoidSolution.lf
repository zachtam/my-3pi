/**
 * Display the outputs from the line sensors on the
 * <a href="https://www.pololu.com/docs/0J86">Pololu 3pi+ 2040 robot</a>.
 * This program spends the first 10 seconds in calibration mode, during which
 * you should move the robot over the light and dark areas that you would like
 * it to detect.  It then switches into measurement mode and displays the
 * measured reflectance of the five IR sensors.
 *
 * @author Abhi Gundrala
 * @author Edward A. Lee
 */
 target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  threading: false,
}

import Line from "lib/Line.lf"
import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"

preamble {=
  #define DRIVE_MODE 0
  #define AVOID_MODE 1
  #define TURNRIGHT_MODE 2
  #define TURNLEFT_MODE 3

  #define DRIVE_SPEED 0.2f
  #define AVOID_SPEED 0.2f
  #define TURN_SPEED 0.1f
=}

reactor Robot {
  input drive_mode:int       // TURNING = 0, DRIVING = 1, AVOIDING = 2
  output notify:string   // Notify of mode change.
  output left_speed:float
  output right_speed:float

  reaction(startup) -> notify {=
    lf_set(notify, "INIT");
  =}

  initial mode CALIBRATING {
    reaction(drive_mode) -> DRIVING, notify, left_speed, right_speed {=
       if (drive_mode->value == DRIVE_MODE) {
        lf_set_mode(DRIVING);
        lf_set(notify, "DRIVING");
        lf_set(left_speed, DRIVE_SPEED);
        lf_set(right_speed, DRIVE_SPEED);
      }     
    =}
  }

  mode TURNRIGHT {
    reaction(drive_mode) -> DRIVING, notify, left_speed, right_speed {=
       if (drive_mode->value == DRIVE_MODE) {
        lf_set_mode(DRIVING);
        lf_set(notify, "DRIVING");
        lf_set(left_speed, DRIVE_SPEED);
        lf_set(right_speed, DRIVE_SPEED);
      }     
    =}
  }

  mode TURNLEFT {
    reaction(drive_mode) -> DRIVING, notify, left_speed, right_speed {=
       if (drive_mode->value == DRIVE_MODE) {
        lf_set_mode(DRIVING);
        lf_set(notify, "DRIVING");
        lf_set(left_speed, DRIVE_SPEED);
        lf_set(right_speed, DRIVE_SPEED);
      }     
    =}
  }

  mode DRIVING {
    reaction(drive_mode) -> AVOIDING, notify, left_speed, right_speed {=
      if (drive_mode->value == AVOID_MODE) {
        lf_set_mode(AVOIDING);
        lf_set(notify, "AVOIDING");
        lf_set(left_speed, -AVOID_SPEED);
        lf_set(right_speed, -AVOID_SPEED);
      }
    =}
  }

  mode AVOIDING {
    reaction(drive_mode) -> DRIVING, TURNLEFT, TURNRIGHT, notify, left_speed, right_speed {=
      if (drive_mode->value == DRIVE_MODE) {
        lf_set_mode(DRIVING);
        lf_set(notify, "DRIVING");
        lf_set(left_speed, DRIVE_SPEED);
        lf_set(right_speed, DRIVE_SPEED);
      }
      if (drive_mode->value == TURNRIGHT_MODE) {
        lf_set_mode(TURNRIGHT);
        lf_set(notify, "TURNRIGHT");
        lf_set(left_speed, TURN_SPEED);
        lf_set(right_speed, -TURN_SPEED);
      }
      if (drive_mode->value == TURNLEFT_MODE) {
        lf_set_mode(TURNLEFT);
        lf_set(notify, "TURNLEFT");
        lf_set(left_speed, -TURN_SPEED);
        lf_set(right_speed, TURN_SPEED);
      }
    =}
  }
}

main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
  line = new Line()
  disp = new Display()
  robot = new Robot()
  motors = new Motors()
  logical action return_to_normal
  logical action turn_left
  logical action turn_right
  timer t(0, sample_period)
  // Timer used to display seconds.
  timer seconds(0, 1 s)
  timer end_calibration(calibration_time)
  state count: int = 0

  reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
    lf_set(disp.line0, "CALIBRATING");
    lf_set(disp.line1, "Roll robot over");
    lf_set(disp.line2, "light and dark.");
  =}

  reaction(seconds) -> disp.line3 {=
    static char buf[17];
    snprintf(buf, 17, "time:%8d s", self->count++);
    lf_set(disp.line3, buf);
  =}

  reaction(end_calibration) -> line.calibrate, robot.drive_mode {=
    lf_set(line.calibrate, false);
    lf_set(robot.drive_mode, DRIVE_MODE);
  =}

  reaction(t) -> line.trigger {=
    lf_set(line.trigger, true);
  =}

  reaction(line.reflect) -> robot.drive_mode, disp.line1, disp.line2, disp.line3, return_to_normal, turn_left, turn_right {=
    static char buf1[17];
    static char buf2[17];
    static char buf3[17];
    if (line.reflect->value[0] > 500 || line.reflect->value[1] > 500) {
        snprintf(buf1, 17, "Left");
        lf_set(robot.drive_mode, AVOID_MODE);
        lf_schedule(turn_right, SEC(0.5));
        lf_schedule(return_to_normal, SEC(0.7));
    }
    else {
      snprintf(buf1, 17, " ");
    }
    if (line.reflect->value[3] > 500 || line.reflect->value[4] > 500) {
        snprintf(buf2, 17, "Right");
        lf_set(robot.drive_mode, AVOID_MODE);
        lf_schedule(turn_left, SEC(0.5));
        lf_schedule(return_to_normal, SEC(0.7));
    }
    else {
      snprintf(buf2, 17, " ");
    }
    if (line.reflect->value[3] > 500 || line.reflect->value[2] > 500 || line.reflect->value[1] > 500) {
        snprintf(buf3, 17, "Center");
        lf_set(robot.drive_mode, AVOID_MODE);
        lf_schedule(turn_left, SEC(0.5));
        lf_schedule(return_to_normal, SEC(0.7));
    }
    else {
      snprintf(buf3, 17, " ");
    }
    lf_set(disp.line1, buf1);
    lf_set(disp.line2, buf2);
    lf_set(disp.line3, buf3);
  =}

  reaction(return_to_normal) -> robot.drive_mode {=
    lf_set(robot.drive_mode, DRIVE_MODE);
  =}

  reaction(turn_left) -> robot.drive_mode {=
    lf_set(robot.drive_mode, TURNLEFT_MODE);
  =}

  reaction(turn_right) -> robot.drive_mode {=
    lf_set(robot.drive_mode, TURNRIGHT_MODE);
  =}

  // robot.notify -> disp.line0;
  robot.left_speed -> motors.left_power;
  robot.right_speed -> motors.right_power;
}
